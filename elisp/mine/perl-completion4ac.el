(require 'cl)
(require 'rx)
(require 'regexp-opt)
(require 'em-glob)
(require 'concurrent)
(require 'perl-completion)
(require 'auto-complete)


(defvar plcmp4ac-builtin-function-hash nil)
(defvar plcmp4ac-builtin-variable-hash nil)

(defvar plcmp4ac-buffer-file-name nil)
(make-variable-buffer-local 'plcmp4ac-buffer-file-name)

(defvar plcmp4ac-current-package-name nil)
(make-variable-buffer-local 'plcmp4ac-current-package-name)

(defvar plcmp4ac-current-context nil)
(defvar plcmp4ac-current-dependent nil)

(defvar plcmp4ac-available-module-hash (make-hash-table :test 'equal))
(defvar plcmp4ac-all-variable-hash (make-hash-table :test 'equal))
(defvar plcmp4ac-should-update-modules nil)
(defvar plcmp4ac-should-update-file-names nil)

(defvar plcmp4ac-ipc-semaphore (cc:semaphore-create 12))

(defvar plcmp4ac-re-perl-package-name (rx-to-string `(and bol (regexp ,plcmp-perl-package-re) eol)))

(defvar plcmp4ac-document-value-at-getting "Getting document ...")
(defvar plcmp4ac-document-value-of-not-found "Not documented.")

(defvar plcmp4ac-max-lisp-eval-depth-org max-lisp-eval-depth)
(defvar plcmp4ac-max-specpdl-size-org max-specpdl-size)


(defun plcmp4ac-toggle-debug ()
  (interactive)
  (if plcmp-debug (setq plcmp-debug nil) (setq plcmp-debug t)))

(defvar plcmp4ac-msg-prefix "[Perl Completion for AC]")
(defun plcmp4ac-echo-info (formatstr &rest s)
  (message (concat "%s " formatstr) plcmp4ac-msg-prefix s))


(defstruct plcmp4ac-module name parents children initxref initparent initdoc initbuff usingmodules oninit
  (memberh (make-hash-table :test 'equal)) (methodh (make-hash-table :test 'equal)) (helptext "")
  (startpt 0) (endpt 0) (varre "") (usingmdlre ""))

(defstruct plcmp4ac-method name belong (fullname "") publicly privately importive params ret (start 0) (end 0)
  (variableh (make-hash-table :test 'equal)) (helptext ""))

(defstruct plcmp4ac-variable name id belong (fullname "") type lexical maybe referencing referenced
  (memberh (make-hash-table :test 'equal)) (helptext "") aftersetmaybehooks)


(defvar plcmp4ac-re-define-plscript (rx-to-string `(and buffer-start (* space) "#!" (* not-newline) "perl" (* not-newline) eol)))
(defvar plcmp4ac-re-define-package (rx-to-string `(and bol (* space) "package" (+ space)
                                                       (group (regexp ,plcmp-perl-package-re))
                                                       (* not-newline) ";")))
(defun plcmp4ac-get-current-package-name ()
  (save-excursion
    (or (when (re-search-backward plcmp4ac-re-define-package nil t)
          (match-string-no-properties 1))
        "main")))

(defun plcmp4ac-get-package-names-in-buffer (buff)
  (when (buffer-live-p buff)
    (save-excursion
      (with-current-buffer buff
        (let* ((founds (loop initially (goto-char (point-min))
                             while (re-search-forward plcmp4ac-re-define-package nil t)
                             collect (match-string-no-properties 1))))
          (cond ((and (stringp plcmp4ac-buffer-file-name)
                      (not (string-match "\\.pm$" plcmp4ac-buffer-file-name))
                      (string-match plcmp4ac-re-define-plscript (buffer-string))
                      (not (member "main" founds)))
                 (push "main" founds))
                (t
                 founds)))))))

(defun plcmp4ac-jump-package-started (pkgnm)
  (let* ((start (point))
         (re (rx-to-string `(and bol (* space) "package" (+ space) (regexp ,pkgnm) (* not-newline) ";"))))
    (goto-char (point-min))
    (if (re-search-forward re nil t)
        (point)
      (goto-char start)
      nil)))

(defun plcmp4ac-get-point-current-package-end ()
  (let* ((re (rx-to-string `(and bol (* space) "1;" (* space) eol))))
    (save-excursion
      (or (when (re-search-forward re nil t) (point))
          (point-max)))))

(defvar plcmp4ac-re-define-use (rx-to-string `(and bol (* space) "use" (+ space)
                                                   (group (regexp ,plcmp-perl-package-re))
                                                   (* not-newline) ";")))
(defvar plcmp4ac-re-define-require (rx-to-string `(and "require" (+ space)
                                                       (group (regexp ,plcmp-perl-package-re)))))
(defun plcmp4ac-get-using-modules (start end)
  (let* ((mdls (plcmp4ac--get-using-modules-uses-and-requires start end))
         (mdls (plcmp--using-modules-marge-extra-modules mdls))
         (mdls (plcmp--using-modules-filter mdls)))
    mdls))

(defun plcmp4ac--get-using-modules-uses-and-requires (start end)
  (save-excursion
    (nunion (loop initially (goto-char start)
                  while (re-search-forward plcmp4ac-re-define-use end t)
                  collect (match-string-no-properties 1))
            (delete-if-not (lambda (s)
                             (member s plcmp-installed-modules))
                           (loop initially (goto-char start)
                                 while (re-search-forward plcmp4ac-re-define-require end t)
                                 collect (match-string-no-properties 1)))
            :test 'string-equal)))

(defsubst* plcmp4ac--check-face (face-names &optional (point (point)))
  (let* ((face (get-text-property point 'face))
         (faces (if (listp face) face (list face))))
    (some (lambda (face-sym)
            (memq face-sym faces))
          face-names)))

(defsubst* plcmp4ac-is-code-face (&optional (point (point)))
  (not (plcmp4ac--check-face '(font-lock-comment-face
                               font-lock-string-face
                               font-lock-doc-face)
                             point)))

(defun plcmp4ac-get-sources-in-buffer (source-name faces buffer-name &optional force)
  (with-current-buffer (get-buffer buffer-name)
    (let ((words (if force
                     (plcmp-add-to-other-perl-buffers-cache-hash source-name faces buffer-name)
                   (or (plcmp-get-other-perl-buffers-cache source-name buffer-name)
                       (plcmp-add-to-other-perl-buffers-cache-hash source-name faces buffer-name)))))
      (loop for w in words
            when (stringp w)
            do (set-text-properties 0 (string-width w) nil w)
            collect (format "%s" w)))))

(defun plcmp4ac-get-current-sources (source-name faces)
  (plcmp4ac-get-sources-in-buffer source-name faces (buffer-name (current-buffer))))

(defun plcmp4ac-get-current-variables (&optional as-struct)
  (plcmp4ac-get-current-sources "variables" '(font-lock-variable-name-face)))

(defun plcmp4ac-get-current-hashes (&optional as-struct)
  (plcmp4ac-get-current-sources "hashes" '(cperl-hash-face)))

(defun plcmp4ac-get-current-arrays (&optional as-struct)
  (plcmp4ac-get-current-sources "arrays" '(cperl-array-face)))

(defun plcmp4ac-get-current-functions (&optional as-struct)
  (plcmp4ac-get-current-sources "functions" '(font-lock-function-name-face)))

(defun plcmp4ac-get-current-others (&optional as-struct)
  (plcmp4ac-get-current-sources "others" '(font-lock-keyword-face
                                           font-lock-builtin-face
                                           font-lock-type-face
                                           font-lock-constant-face)))

(defsubst* plcmp4ac-render-html (html)
  (cond ((not (stringp html))
         "")
        ((require 'w3m nil t)
         (flet ((w3m-message (&rest args) nil))
           (with-temp-buffer
             (insert html)
             (w3m-region (point-min) (point-max))
             (buffer-string))))
        (t 
         "")))

(defun plcmp4ac-index-of-closed-bracket-curly (str startindex)
  (plcmp4ac-index-of-closed-bracket str startindex "(" ")"))

(defun plcmp4ac-index-of-closed-bracket-wavy (str startindex)
  (plcmp4ac-index-of-closed-bracket str startindex "{" "}"))

(defun plcmp4ac-index-of-closed-bracket-angled (str startindex)
  (plcmp4ac-index-of-closed-bracket str startindex "[" "]"))

(defun plcmp4ac-index-of-closed-bracket (str index start end)
  (loop with depth = 1
        for i from index below (length str)
        for c = (substring str i (+ i 1))
        if (string= c start) do (incf depth)
        if (string= c end) do (decf depth)
        if (= depth 0) return i
        finally return (length str)))

(defun plcmp4ac-update-current-context ()
  (setq plcmp4ac-current-context nil)
  (setq plcmp4ac-current-dependent nil)
  (multiple-value-setq
      (plcmp-initial-input plcmp-real-initial-input) (plcmp-get-initial-real-input-list))
  (multiple-value-bind (ctx mdlnm) (plcmp--get-context-symbol)
    (setq plcmp4ac-current-context ctx)
    (setq plcmp4ac-current-dependent mdlnm)))

(defun plcmp4ac-initialize-variables (&optional not-update-context)
  ;; (setq plcmp-installed-modules (plcmp-get-installed-modules)
  ;;       plcmp4ac-current-package-name (plcmp4ac-get-current-package-name))
  ;; (when (not not-update-context)
  ;;   (plcmp4ac-update-current-context))
  )

(defun plcmp4ac-make-candidates ()
  (case plcmp4ac-current-context
    (package (append (plcmp4ac-get-all-methods-in-module plcmp4ac-current-package-name)
                     (mapcar (lambda (x) (concat "SUPER::" x))
                             (plcmp4ac-get-inherit-methods-in-module plcmp4ac-current-package-name))))
    (method (cond ((not (stringp plcmp4ac-current-dependent))
                   (plcmp4ac-get-static-methods-in-current))
                  ((or (string= plcmp4ac-current-dependent "$self")
                       (string= plcmp4ac-current-dependent "$class"))
                   (append (plcmp4ac-get-all-methods-in-module plcmp4ac-current-package-name)
                           (mapcar (lambda (x) (concat "SUPER::" x))
                                   (plcmp4ac-get-inherit-methods-in-module plcmp4ac-current-package-name))))
                  ((string= plcmp4ac-current-dependent "SUPER")
                   (plcmp4ac-get-inherit-methods-in-module plcmp4ac-current-package-name))
                  ((member plcmp4ac-current-dependent plcmp-installed-modules)
                   (plcmp4ac-get-static-methods-in-module plcmp4ac-current-dependent))
                  (t
                   (plcmp4ac-get-maybe-modules-methods-of-variable plcmp4ac-current-dependent))))
    (variable (append (plcmp4ac-get-available-scalars)
                      (plcmp4ac-get-available-arrays-on-scalar)
                      (plcmp4ac-get-available-hashes-on-scalar)
                      (plcmp4ac-get-available-arrays-on-arraysize)))
    (array (plcmp4ac-get-available-arrays))
    (hash (plcmp4ac-get-available-hashes))
    (function (plcmp4ac-get-available-methods-on-amp))
    ;; (installed-module plcmp-installed-modules)
    (otherwise (append (loop for m in (plcmp4ac-module-usingmodules (plcmp4ac-get-module-info plcmp4ac-current-package-name))
                             collect (plcmp4ac-module-name m))
                       (plcmp4ac-get-static-methods-in-current)
                       (plcmp4ac-get-current-others)))))

(defun plcmp4ac-get-available-variables (var-type &optional as-struct)
  (let* ((currmdl (plcmp4ac-get-module-info plcmp4ac-current-package-name))
         (type-char (case var-type
                      (plcmp4ac-scalar "$")
                      (plcmp4ac-array  "@")
                      (plcmp4ac-hash   "%"))))
    (append (loop for m in (plcmp4ac-module-usingmodules currmdl)
                  if (eq var-type 'plcmp4ac-scalar)
                  append (plcmp4ac-get-public-variables-in-module m var-type as-struct))
            (cond (as-struct
                   (loop for v being the hash-values in (plcmp4ac-module-memberh currmdl)
                         if (eq (plcmp4ac-variable-type v) var-type) collect v)
                   (loop for m in (plcmp4ac-module-parents currmdl)
                         append (plcmp4ac-get-public-variables-in-module m var-type t)))
                  (t
                   (case var-type
                     (plcmp4ac-scalar (plcmp4ac-get-current-variables))
                     (plcmp4ac-array  (plcmp4ac-get-current-arrays))
                     (plcmp4ac-hash   (plcmp4ac-get-current-hashes)))))
            (cond (as-struct
                   (loop for v being the hash-values in plcmp4ac-builtin-variable-hash
                         if (eq (plcmp4ac-variable-type v) var-type) collect v))
                  (t
                   (loop for v in plcmp-builtin-variables
                         if (string= (substring v 0 1) type-char) collect v))))))

(defun plcmp4ac-get-available-scalars (&optional as-struct)
  (plcmp4ac-get-available-variables 'plcmp4ac-scalar as-struct))

(defun plcmp4ac-get-available-arrays (&optional as-struct)
  (plcmp4ac-get-available-variables 'plcmp4ac-array as-struct))

(defun plcmp4ac-get-available-hashes (&optional as-struct)
  (plcmp4ac-get-available-variables 'plcmp4ac-hash as-struct))

(defun plcmp4ac-get-available-arrays-on-scalar ()
  (mapcar (lambda (x) (replace-regexp-in-string "^@" "$" x))
          (plcmp4ac-get-available-arrays)))

(defun plcmp4ac-get-available-hashes-on-scalar ()
  (mapcar (lambda (x) (replace-regexp-in-string "^%" "$" x))
          (plcmp4ac-get-available-hashes)))

(defun plcmp4ac-get-available-arrays-on-arraysize ()
  (mapcar (lambda (x) (replace-regexp-in-string "^@" "$#" x))
          (plcmp4ac-get-available-arrays)))

(defun plcmp4ac-get-available-methods-on-amp ()
  (mapcar (lambda (x) (concat "&" x)) (plcmp4ac-get-static-methods-in-current)))

(defun plcmp4ac-get-static-methods-in-current (&optional as-struct)
  (let* ((currmdl (plcmp4ac-get-module-info plcmp4ac-current-package-name)))
    (append (loop for m in (plcmp4ac-module-usingmodules currmdl)
                  append (plcmp4ac-get-static-methods-in-module m as-struct t))
            (cond ((string= plcmp4ac-current-package-name "main")
                   (plcmp4ac-get-current-functions as-struct))
                  (t
                   (plcmp4ac-get-all-methods-in-module currmdl as-struct)))
            (cond (as-struct
                   (loop for v being the hash-values in plcmp4ac-builtin-function-hash collect v))
                  (t
                   plcmp-builtin-functions)))))

(defun plcmp4ac-get-static-methods-in-module (mdl_or_name &optional as-struct include-fullname)
  (let* ((mdl (if (plcmp4ac-module-p mdl_or_name)
                     mdl_or_name
                   (plcmp4ac-get-module-info mdl_or_name))))
    (when (plcmp4ac-module-p mdl)
      (append (plcmp4ac-get-public-methods-in-module mdl_or_name as-struct include-fullname)
              (loop for m being the hash-values in (plcmp4ac-module-methodh mdl)
                    if (plcmp4ac-method-importive m)
                    if as-struct collect m
                    else         append (append (list (plcmp4ac-method-name m))
                                                (when include-fullname
                                                  (list (plcmp4ac-method-fullname m)))))))))

(defun plcmp4ac-get-public-methods-in-module (mdl_or_name &optional as-struct include-fullname not-include-parent)
  (let* ((mdl (if (plcmp4ac-module-p mdl_or_name)
                     mdl_or_name
                   (plcmp4ac-get-module-info mdl_or_name))))
    (when (plcmp4ac-module-p mdl)
      (append (loop for m being the hash-values in (plcmp4ac-module-methodh mdl)
                    if (plcmp4ac-method-publicly m)
                    if as-struct collect m
                    else         append (append (list (plcmp4ac-method-name m))
                                                (when include-fullname
                                                  (list (plcmp4ac-method-fullname m)))))
              (when (not not-include-parent)
                (loop for m in (plcmp4ac-module-parents mdl)
                      append (plcmp4ac-get-public-methods-in-module m as-struct include-fullname)))))))

(defun plcmp4ac-get-not-private-methods-in-module (mdl_or_name &optional as-struct)
  (let* ((mdl (if (plcmp4ac-module-p mdl_or_name)
                     mdl_or_name
                   (plcmp4ac-get-module-info mdl_or_name))))
    (when (plcmp4ac-module-p mdl)
      (append (loop for m being the hash-values in (plcmp4ac-module-methodh mdl)
                    if (not (plcmp4ac-method-privately m))
                    collect (if as-struct m (plcmp4ac-method-name m)))
              (loop for m in (plcmp4ac-module-parents mdl)
                    append (plcmp4ac-get-not-private-methods-in-module m as-struct))))))

(defun plcmp4ac-get-inherit-methods-in-module (mdl_or_name &optional as-struct)
  (let* ((mdl (if (plcmp4ac-module-p mdl_or_name)
                     mdl_or_name
                   (plcmp4ac-get-module-info mdl_or_name))))
    (when (plcmp4ac-module-p mdl)
      (loop for m in (plcmp4ac-module-parents mdl)
            append (plcmp4ac-get-not-private-methods-in-module m as-struct)))))

(defun plcmp4ac-get-all-methods-in-module (mdl_or_name &optional as-struct)
  (let* ((mdl (if (plcmp4ac-module-p mdl_or_name)
                     mdl_or_name
                   (plcmp4ac-get-module-info mdl_or_name))))
    (when (plcmp4ac-module-p mdl)
      (append (loop for m being the hash-values in (plcmp4ac-module-methodh mdl)
                    collect (if as-struct m (plcmp4ac-method-name m)))
              (plcmp4ac-get-inherit-methods-in-module mdl as-struct)))))

(defun plcmp4ac-get-public-variables-in-module (mdl_or_name var-type &optional as-struct)
  (let* ((mdl (if (plcmp4ac-module-p mdl_or_name)
                     mdl_or_name
                   (plcmp4ac-get-module-info mdl_or_name))))
    (when (plcmp4ac-module-p mdl)
      (append (loop for v being the hash-values in (plcmp4ac-module-memberh mdl)
                    if (and (not (plcmp4ac-variable-lexical v))
                            (eq (plcmp4ac-variable-type v) var-type))
                    if as-struct collect v
                    else         append (list (plcmp4ac-variable-name v)
                                              (plcmp4ac-variable-fullname v)))
              (loop for m in (plcmp4ac-module-parents mdl)
                    append (plcmp4ac-get-public-variables-in-module m var-type as-struct))))))

(defun plcmp4ac-get-public-scalars-in-module (mdl_or_name &optional as-struct)
  (plcmp4ac-get-public-variables-in-module mdl_or_name 'plcmp4ac-scalar as-struct))

(defun plcmp4ac-get-public-arrays-in-module (mdl_or_name &optional as-struct)
  (plcmp4ac-get-public-variables-in-module mdl_or_name 'plcmp4ac-array as-struct))

(defun plcmp4ac-get-public-hashes-in-module (mdl_or_name &optional as-struct)
  (plcmp4ac-get-public-variables-in-module mdl_or_name 'plcmp4ac-hash as-struct))

(defun plcmp4ac-get-all-variables-in-module (mdl &optional as-struct)
  (append (plcmp4ac-get-all-members-in-module mdl as-struct)
          (loop for v being the hash-values in (plcmp4ac-module-methodh mdl)
                append (plcmp4ac-get-all-variables-in-method v as-struct))))

(defun plcmp4ac-get-all-members-in-module (mdl &optional as-struct)
  (loop for v being the hash-values in (plcmp4ac-module-memberh mdl)
        append (plcmp4ac-get-all-variables-in-variable v as-struct)))

(defun plcmp4ac-get-all-variables-in-method (mtd &optional as-struct)
  (loop for v being the hash-values in (plcmp4ac-method-variableh mtd)
        append (plcmp4ac-get-all-variables-in-variable v as-struct)))

(defun plcmp4ac-get-all-variables-in-variable (var &optional as-struct)
  (let* ((members (loop for v being the hash-values in (plcmp4ac-variable-memberh var)
                        append (plcmp4ac-get-all-variables-in-variable var as-struct)))
         (myself (cond (as-struct var)
                       (t         (plcmp4ac-variable-name var)))))
    (cond ((> (length members) 0) (append (list myself) members))
          (t                      (list myself)))))

(defsubst* plcmp4ac-get-method-on-point (mdl point)
  (loop for mtd being the hash-values in (plcmp4ac-module-methodh mdl)
        if (and (>= point (plcmp4ac-method-start mtd))
                (<= point (plcmp4ac-method-end mtd)))
        return mtd))

(defun plcmp4ac-get-maybe-modules-methods-of-variable (varnm &optional as-struct)
  (let* ((mdl (plcmp4ac-get-module-info plcmp4ac-current-package-name))
         (mtd (plcmp4ac-get-method-on-point mdl (point)))
         (var (or (when (plcmp4ac-method-p mtd)
                    (gethash varnm (plcmp4ac-method-variableh mtd)))
                  (when (plcmp4ac-module-p mdl)
                    (gethash varnm (plcmp4ac-module-memberh mdl)))))
         (maybe (when (plcmp4ac-variable-p var)
                  (plcmp4ac-variable-maybe var))))
    (when (plcmp4ac-module-p maybe)
      (plcmp4ac-get-public-methods-in-module maybe as-struct))))

(defun plcmp4ac-build-module-info (mdlnm &optional force is_current)
  (when (and (stringp mdlnm) (not (string= mdlnm "")))
    (let* ((mdl (plcmp4ac-get-module-info mdlnm force)))
      (when (plcmp4ac-module-p mdl)
        (let* ((initxref (plcmp4ac-module-initxref mdl))
               (initparent (plcmp4ac-module-initparent mdl))
               (initdoc (plcmp4ac-module-initdoc mdl))
               (initbuff (plcmp4ac-module-initbuff mdl))
               (oninit (plcmp4ac-module-oninit mdl)))
          (when (or force (not initxref) (not initparent) (not initdoc) (not initbuff))
            (when (not oninit)
              (setf (plcmp4ac-module-oninit mdl) t)
              (plcmp-log "plcmp4ac-build-module-info Start for %s (force:%s is_current:%s)" mdlnm force is_current)
              (when (or force (not initxref))
                (plcmp4ac-build-module-xref-info mdl))
              (when (or force (not initparent))
                (plcmp4ac-build-module-inheritance-info mdl))
              (when (or force (not initdoc))
                (plcmp4ac-build-module-doc-info mdl))
              (when (or force (not initbuff))
                (plcmp4ac-build-module-buffer-info mdl is_current force))
              (setf (plcmp4ac-module-oninit mdl) nil))))))))

(defun plcmp4ac-build-parent-module-info (mdl)
  (when (plcmp4ac-module-p mdl)
    (dolist (m (plcmp4ac-module-parents mdl))
      (plcmp4ac-build-module-info (plcmp4ac-module-name m)))))

(defun plcmp4ac-build-using-module-info (mdl)
  (when (plcmp4ac-module-p mdl)
    (dolist (m (plcmp4ac-module-usingmodules mdl))
      (plcmp4ac-build-module-info (plcmp4ac-module-name m)))))

(defun plcmp4ac-get-module-info (mdlnm &optional do_init)
  (when (and (stringp mdlnm) (not (string= mdlnm "")))
    (cond ((string= mdlnm "main")
           (or (when (and (not do_init) (stringp plcmp4ac-buffer-file-name))
                 (gethash plcmp4ac-buffer-file-name plcmp4ac-available-module-hash))
               (puthash plcmp4ac-buffer-file-name (make-plcmp4ac-module :name "main") plcmp4ac-available-module-hash)))
          (t
           (when (string-match plcmp4ac-re-perl-package-name mdlnm)
             (or (when (not do_init)
                   (gethash mdlnm plcmp4ac-available-module-hash))
                 (puthash mdlnm (make-plcmp4ac-module :name mdlnm) plcmp4ac-available-module-hash)))))))

(defun plcmp4ac-save-module-info (mdl)
  )

(defun plcmp4ac-update-module-info ()
  (let* ((currentpkgs (plcmp4ac-get-package-names-in-buffer (current-buffer))))
    (while (> (length plcmp4ac-should-update-modules) 0)
      (let* ((mdlnm (pop plcmp4ac-should-update-modules))
             (is_current (member mdlnm currentpkgs)))
        (plcmp4ac-build-module-info mdlnm t is_current)))
    (while (> (length plcmp4ac-should-update-file-names) 0)
      (let* ((filepath (pop plcmp4ac-should-update-file-names))
             (buff (loop for b in (buffer-list)
                         for filenm = (buffer-file-name b)
                         if (and (stringp filenm) (string= filepath filenm)) return b)))
        (when (buffer-live-p buff)
          (with-current-buffer buff
            (plcmp4ac-build-module-info "main" t t)))))))

(defvar plcmp4ac-re-xref-sub (rx-to-string `(and bol (= 2 space) "Subroutine" (+ space) (group (+ not-newline)))))
(defvar plcmp4ac-re-xref-pkg (rx-to-string `(and bol (= 4 space) "Package" (+ space) (group (+ not-newline)))))
(defvar plcmp4ac-re-xref-def (rx-to-string `(and bol (+ space) (group (any "$" "@" "%" "&"))
                                                 (group (regexp ,plcmp-perl-ident-re))
                                                 (+ space) (group (+ anything)) eol)))
(defvar plcmp4ac-re-xref-cut (rx-to-string `(and bol (group (+ not-newline))
                                                 "::"
                                                 (group (+ (not (any ":")))) eol)))
(defvar plcmp4ac-re-perl-ident-value (rx-to-string `(and bol (regexp ,plcmp-perl-ident-re) eol)))

(lexical-let* (mdl subnm idtype idvalue etcinfo methodh)

  (defun plcmp4ac-build-module-xref-info (targetmdl)
    (setq mdl targetmdl)
    (when (and (plcmp4ac-module-p mdl)
               (not (string= (plcmp4ac-module-name mdl) "main")))
      (setf (plcmp4ac-module-initxref mdl) t)
      (setq methodh (plcmp4ac-module-methodh mdl))
      (plcmp-log "plcmp4ac-build-module-xref-info Start for %s" (plcmp4ac-module-name mdl))
      (plcmp-with-set-perl5-lib
       (let* ((mdlnm (plcmp4ac-module-name mdl))
              (xrefinfo (shell-command-to-string (concat "perl -MO=Xref -e 'use " mdlnm "'"))))
         (with-temp-buffer
           (insert xrefinfo)
           (loop with pkg
                 with tmp
                 initially (goto-char (point-min))
                 for line = (thing-at-point 'line)
                 for line = (progn (set-text-properties 0 (string-width line) nil line)
                                   line)
                 until (eobp)
                 do (cond ((string-match plcmp4ac-re-xref-sub line)
                           (setq tmp (match-string-no-properties 1 line))
                           (cond ((string= tmp "(definitions)")
                                  (setq pkg nil)
                                  (setq subnm nil))
                                 ((string-match plcmp4ac-re-xref-cut tmp)
                                  (setq pkg (match-string-no-properties 1 tmp))
                                  (setq subnm (match-string-no-properties 2 tmp)))
                                 (t
                                  (setq subnm nil))))
                          ((string-match plcmp4ac-re-xref-pkg line)
                           (setq tmp (match-string-no-properties 1 line))
                           (cond ((string-match plcmp4ac-re-perl-package-name tmp) (setq pkg tmp))
                                 ((string= tmp "main")                             (setq pkg tmp))))
                          ((string-match plcmp4ac-re-xref-def line)
                           (setq idtype (match-string-no-properties 1 line))
                           (setq idvalue (match-string-no-properties 2 line))
                           (setq etcinfo (match-string-no-properties 3 line))
                           (when (and (stringp pkg) (not (string= pkg "")) (string= pkg mdlnm))
                             (plcmp4ac-build-from-xref-defined))))
                 do (forward-line 1))
           (plcmp-log "plcmp4ac-build-module-xref-info Got %s methods are %s"
                      mdlnm
                      (mapconcat 'identity (loop for k being the hash-keys in (plcmp4ac-module-methodh mdl) collect k) ", "))
           (plcmp-log "plcmp4ac-build-module-xref-info Got %s members are %s"
                      mdlnm
                      (mapconcat 'identity (loop for k being the hash-keys in (plcmp4ac-module-memberh mdl) collect k) ", "))
           (loop for mtdnm being the hash-keys in (plcmp4ac-module-methodh mdl) using (hash-values mtd)
                 for vars = (loop for k being the hash-keys in (plcmp4ac-method-variableh mtd) collect k)
                 do (plcmp-log "plcmp4ac-build-module-xref-info Got %s::%s variables are %s"
                               mdlnm
                               mtdnm
                               (mapconcat 'identity vars ", "))))))))
  
  (defsubst* plcmp4ac-build-from-xref-defined ()
    (let* ((mtd (when (stringp subnm)
                     (or (gethash subnm methodh)
                         (puthash subnm
                                  (make-plcmp4ac-method :name subnm :fullname (concat (plcmp4ac-module-name mdl) "::" subnm) :belong mdl)
                                  methodh))))
           (varnm (concat idtype idvalue)))
      ;; Defined public method if line is "Subroutine ..."
      (when (plcmp4ac-method-p mtd)
        (when (and (not (string= (substring subnm 0 1) "_"))
                   (not (string= (upcase subnm) subnm)))
          (setf (plcmp4ac-method-publicly mtd) t))
        (setf (plcmp4ac-method-ret mtd) (make-plcmp4ac-variable :name subnm :id subnm :fullname (plcmp4ac-method-fullname mtd) :belong mtd :lexical t)))
      (when (string-match plcmp4ac-re-perl-ident-value idvalue)
        (cond ((string= idtype "&")
               (when (not (gethash idvalue methodh))
                 ;; Defined private method if line is "&...", and not member yet
                 (let* ((mtd (puthash idvalue
                                         (make-plcmp4ac-method :name idvalue :fullname (concat (plcmp4ac-module-name mdl) "::" idvalue) :belong mdl :publicly nil)
                                         methodh)))
                   (setf (plcmp4ac-method-ret mtd) (make-plcmp4ac-variable :name idvalue :id idvalue :fullname (plcmp4ac-method-fullname mtd) :belong mtd :lexical t)))))
              ((not (member varnm plcmp-builtin-variables))
               (let* ((lexical (string-match "i" etcinfo))
                      (variableh (cond ((and lexical (plcmp4ac-method-p mtd))
                                        (plcmp4ac-method-variableh mtd))
                                       (t
                                        (plcmp4ac-module-memberh mdl))))
                      (var (when (hash-table-p variableh)
                             (or (gethash varnm variableh)
                                 (puthash varnm
                                          (make-plcmp4ac-variable :name varnm
                                                                  :id idvalue
                                                                  :belong (if lexical mtd mdl)
                                                                  :fullname (concat idtype
                                                                                    (if lexical (plcmp4ac-method-fullname mtd) (plcmp4ac-module-name mdl))
                                                                                    "::"
                                                                                    idvalue)
                                                                  :lexical lexical
                                                                  :helptext (if lexical plcmp4ac-document-value-of-not-found ""))
                                          variableh)))))
                 (when (plcmp4ac-variable-p var)
                   (when (not (gethash (plcmp4ac-variable-fullname var) plcmp4ac-all-variable-hash))
                     (puthash (plcmp4ac-variable-fullname var) var plcmp4ac-all-variable-hash))
                   (cond ((string= idtype "$")
                          (setf (plcmp4ac-variable-type var) 'plcmp4ac-scalar))
                         ((string= idtype "@")
                          (setf (plcmp4ac-variable-type var) 'plcmp4ac-array))
                         ((string= idtype "%")
                          (setf (plcmp4ac-variable-type var) 'plcmp4ac-hash))))))))))

  )

(defun plcmp4ac-build-module-inheritance-info (mdl)
  (when (and (plcmp4ac-module-p mdl)
             (not (string= (plcmp4ac-module-name mdl) "main")))
    (setf (plcmp4ac-module-initparent mdl) t)
    (lexical-let* ((mdlnm (plcmp4ac-module-name mdl)))
      (plcmp-with-set-perl5-lib
       (deferred:$
         (deferred:process-shell-bufferc (cc:semaphore-acquire plcmp4ac-ipc-semaphore)
           (progn (plcmp-log "plcmp4ac-build-module-inheritance-info Start for %s" mdlnm)
                  "perl")
           "-e" (concat "'use " mdlnm "; print join \"\n\"=>@" mdlnm "::ISA'"))
         (deferred:error it
           (lambda (buff)
             (when (buffer-live-p buff)
               (with-current-buffer buff
                 (plcmp4ac-echo-info "Can't get info of %s" mdlnm)
                 (plcmp-log "plcmp4ac-build-module-inheritance-info %s" (buffer-string))
                 (kill-buffer (current-buffer))))))
         (deferred:nextc it
           (lambda (buff)
             (cc:semaphore-release plcmp4ac-ipc-semaphore)
             (when (buffer-live-p buff)
               (with-current-buffer buff
                 (let* ((mdl (plcmp4ac-get-module-info mdlnm))
                        (cmdret (buffer-string))
                        (parents (when (and (not (plcmp-notfound-p cmdret))
                                            (stringp cmdret))
                                   (loop for parentnm in (split-string cmdret)
                                         for p = (plcmp4ac-get-module-info parentnm)
                                         if (plcmp4ac-module-p p) collect p))))
                   (if (= (length parents) 0)
                       (plcmp-log "plcmp4ac-build-module-inheritance-info %s don't have parent" mdlnm)
                     (setf (plcmp4ac-module-parents mdl) parents)
                     (dolist (p parents)
                       (when (not (plcmp4ac-module-initxref p))
                         (plcmp4ac-build-module-xref-info p))
                       (when (not (memq mdl (plcmp4ac-module-children p)))
                         (push mdl (plcmp4ac-module-children p))))
                     (plcmp-log "plcmp4ac-build-module-inheritance-info Got %s parents are %s"
                                mdlnm
                                (mapconcat 'identity (loop for p in parents collect (plcmp4ac-module-name p)) ", "))
                     (plcmp4ac-build-parent-module-info mdl)))
                 (kill-buffer (current-buffer)))))))))))

(defun plcmp4ac-build-module-doc-info (mdl)
  (when (and (plcmp4ac-module-p mdl)
             (not (string= (plcmp4ac-module-name mdl) "main")))
    (setf (plcmp4ac-module-initdoc mdl) t)
    (lexical-let* ((mdlnm (plcmp4ac-module-name mdl)))
      (setf (plcmp4ac-module-helptext mdl) plcmp4ac-document-value-at-getting)
      (loop for v being the hash-values in (plcmp4ac-module-memberh mdl)
            do (setf (plcmp4ac-variable-helptext v) plcmp4ac-document-value-at-getting))
      (loop for m being the hash-values in (plcmp4ac-module-methodh mdl)
            do (setf (plcmp4ac-method-helptext m) plcmp4ac-document-value-at-getting))
      (plcmp-with-set-perl5-lib
       (deferred:$
         (deferred:process-shell-bufferc (cc:semaphore-acquire plcmp4ac-ipc-semaphore)
           (progn (plcmp-log "plcmp4ac-build-module-doc-info Start for %s" mdlnm)
                  "perldoc")
           "-oHtml" mdlnm)
         (deferred:error it
           (lambda (buff)
             (when (buffer-live-p buff)
               (with-current-buffer buff
                 (plcmp4ac-echo-info "Can't get info of %s" mdlnm)
                 (plcmp-log "plcmp4ac-build-module-doc-info %s" (buffer-string))
                 (kill-buffer (current-buffer))))))
         (deferred:nextc it
           (lambda (buff)
             (cc:semaphore-release plcmp4ac-ipc-semaphore)
             (when (buffer-live-p buff)
               (with-current-buffer buff
                 (let* ((mdl (plcmp4ac-get-module-info mdlnm))
                        (memberh (plcmp4ac-module-memberh mdl))
                        (methodh (plcmp4ac-module-methodh mdl)))
                   (setf (plcmp4ac-module-helptext mdl) (plcmp4ac-render-html (buffer-string)))
                   (plcmp-log "plcmp4ac-build-module-doc-info Got %s" mdlnm)
                   (plcmp4ac-parse-module-doc-info memberh methodh))
                 (kill-buffer (current-buffer)))))))))))

(defsubst* plcmp4ac-parse-module-doc-info (memberh methodh)
  (let* ((candidateh (make-hash-table :test 'equal))
         (candidates (append (loop for mtdnm being the hash-keys in methodh using (hash-values mtd)
                                   do (puthash mtdnm mtd candidateh)
                                   collect mtdnm)
                             (loop for var being the hash-values in memberh
                                   for varid = (plcmp4ac-variable-id var)
                                   do (puthash varid var candidateh)
                                   collect varid)))
         (re-cand (regexp-opt candidates))
         (regist-doc (lambda (foundnm html)
                       (let* ((found (gethash foundnm candidateh))
                              (newdoc (plcmp4ac-render-html html))
                              (olddoc (cond ((plcmp4ac-method-p found)
                                             (plcmp4ac-method-helptext found))
                                            ((plcmp4ac-variable-p found)
                                             (plcmp4ac-variable-helptext found))
                                            (t
                                             "")))
                              (doc (if (string= olddoc plcmp4ac-document-value-at-getting)
                                       newdoc
                                     (concat olddoc "\n\n" newdoc))))
                         (cond ((plcmp4ac-method-p found)
                                (setf (plcmp4ac-method-helptext found) doc)
                                (plcmp-log "plcmp4ac-build-module-doc-info Got %s" (plcmp4ac-method-fullname found)))
                               ((plcmp4ac-variable-p found)
                                (setf (plcmp4ac-variable-helptext found) doc)
                                (plcmp-log "plcmp4ac-build-module-doc-info Got %s" (plcmp4ac-variable-fullname found))))))))
    (plcmp4ac-parse-module-doc-info-by-dt re-cand regist-doc)
    (loop for mtd being the hash-values in methodh
          if (string= (plcmp4ac-method-helptext mtd) plcmp4ac-document-value-at-getting)
          do (progn (plcmp-log "plcmp4ac-build-module-doc-info Not found %s" (plcmp4ac-method-fullname mtd))
                    (setf (plcmp4ac-method-helptext mtd) plcmp4ac-document-value-of-not-found)))
    (loop for var being the hash-values in memberh
          if (string= (plcmp4ac-variable-helptext var) plcmp4ac-document-value-at-getting)
          do (progn (plcmp-log "plcmp4ac-build-module-doc-info Not found %s" (plcmp4ac-variable-fullname var))
                    (setf (plcmp4ac-variable-helptext var) plcmp4ac-document-value-of-not-found)))))

(defsubst* plcmp4ac-parse-module-doc-info-by-dt (re-cand regist-doc)
  (let* ((re (rx-to-string `(and "<dt><a name=\"" (group (regexp ,re-cand))))))
    (goto-char (point-min))
    (while (re-search-forward re nil t)
      (let* ((found (match-string-no-properties 1))
             (start (save-excursion (search-backward "<dt>" nil t)
                                    (forward-char -4)
                                    (point)))
             (end (or (when (search-forward "<dt>" nil t)
                        (forward-char -4)
                        (point))
                      (when (search-forward "</dl>" nil t)
                        (forward-char -5)
                        (point))
                      (point-max))))
        (funcall regist-doc found (buffer-substring-no-properties start end))))))

(defun plcmp4ac-build-module-buffer-info (mdl &optional is_current thisonly)
  (when (plcmp4ac-module-p mdl)
    (if (and (not (string= (plcmp4ac-module-name mdl) "main"))
             (= (length (plcmp4ac-get-public-methods-in-module mdl nil nil t)) 0))
        (setf (plcmp4ac-module-initbuff mdl) t)
      (cond (is_current
             (let* ((text (buffer-string))
                    (filenm (buffer-file-name)))
               (with-temp-buffer
                 (insert text)
                 (setq plcmp4ac-buffer-file-name filenm)
                 (plcmp4ac-build-current-buffer-module-info (plcmp4ac-module-name mdl)))))
            (t
             (lexical-let* ((mdlnm (plcmp4ac-module-name mdl))
                            (thisonly thisonly))
               (plcmp-with-set-perl5-lib
                (deferred:$
                  (deferred:process-shell-bufferc (cc:semaphore-acquire plcmp4ac-ipc-semaphore)
                    (progn (plcmp-log "plcmp4ac-build-module-buffer-info Start for %s" mdlnm)
                           "perldoc")
                    "-m" mdlnm)
                  (deferred:error it
                    (lambda (buff)
                      (when (buffer-live-p buff)
                        (with-current-buffer buff
                          (plcmp4ac-echo-info "Can't get info of %s" mdlnm)
                          (plcmp-log "plcmp4ac-build-module-buffer-info %s" (buffer-string))
                          (kill-buffer (current-buffer))))))
                  (deferred:nextc it
                    (lambda (buff)
                      (cc:semaphore-release plcmp4ac-ipc-semaphore)
                      (when (buffer-live-p buff)
                        (with-current-buffer buff
                          (setq max-lisp-eval-depth 10000)
                          (setq max-specpdl-size 8000)
                          (unwind-protect
                              (cond (thisonly (plcmp4ac-build-current-buffer-module-info mdlnm))
                                    (t        (plcmp4ac-build-current-buffer-module-info)))
                            (setq max-lisp-eval-depth plcmp4ac-max-lisp-eval-depth-org)
                            (setq max-specpdl-size plcmp4ac-max-specpdl-size-org))
                          (kill-buffer (current-buffer))))))))))))))

(defun plcmp4ac-build-current-buffer-module-info (&optional mdlnm)
  (plcmp4ac-delete-pod-in-current-buffer)
  (plcmp4ac-delete-comment-in-current-buffer)
  (let* ((mdlnmlist (cond ((stringp mdlnm) (list mdlnm))
                             (t                  (plcmp4ac-get-package-names-in-buffer (current-buffer))))))
    (loop for m in mdlnmlist
          for mdl = (plcmp4ac-get-module-info m)
          for start = (cond ((plcmp4ac-jump-package-started m) (point))
                            ((string= m "main") (goto-char (point-min)) (point)))
          for end = (cond ((string= m "main")
                           (cond ((re-search-forward plcmp4ac-re-define-package nil t)
                                  (beginning-of-line)
                                  (point))
                                 (t
                                  (point-max))))
                          (t
                           (plcmp4ac-get-point-current-package-end)))
          do (when (plcmp4ac-module-p mdl)
               (if (and (not (stringp mdlnm)) (plcmp4ac-module-initbuff mdl))
                   (plcmp-log "plcmp4ac-build-current-buffer-module-info Already inited %s" m)
                 (setf (plcmp4ac-module-initbuff mdl) t)
                 (plcmp4ac-initialize-variables t)
                 (if (or (not (number-or-marker-p start)) (not (number-or-marker-p end)) (<= end start))
                     (plcmp-log "plcmp4ac-build-current-buffer-module-info Can't start for %s (%s - %s)" m start end)
                   (plcmp-log "plcmp4ac-build-current-buffer-module-info Start for %s (%s - %s)" m start end)
                   (setf (plcmp4ac-module-usingmodules mdl) (loop for m in (plcmp4ac-get-using-modules start end)
                                                                     for mdl = (plcmp4ac-get-module-info m)
                                                                     if (and (plcmp4ac-module-p mdl)
                                                                             (not (plcmp4ac-module-initxref mdl)))
                                                                     do (plcmp4ac-build-module-xref-info mdl)
                                                                     if (plcmp4ac-module-p mdl)
                                                                     collect mdl))
                   (setf (plcmp4ac-module-startpt mdl) start)
                   (setf (plcmp4ac-module-endpt mdl) end)
                   (save-excursion
                     (plcmp4ac-build-module-unknown-variables mdl)
                     (plcmp4ac-build-module-method-range-info mdl)
                     (setf (plcmp4ac-module-varre mdl)
                           (regexp-opt (loop for v in (plcmp4ac-get-all-variables-in-module module t) collect (plcmp4ac-variable-id v))))
                     (setf (plcmp4ac-module-usingmdlre mdl)
                           (regexp-opt (loop for m in (plcmp4ac-module-usingmodules module) collect (plcmp4ac-module-name m))))
                     (plcmp4ac-build-substituted-variable-in-module mdl)
                     (plcmp4ac-build-method-returned-in-module mdl)
                     (plcmp4ac-build-argument-received-in-module mdl))
                   (plcmp-log "plcmp4ac-build-current-buffer-module-info Got %s" m)
                   (plcmp4ac-build-using-module-info mdl)))))))

(defvar plcmp4ac-pod-commands '("head1" "head2" "head3" "head4" "over" "item" "back" "pod" "begin" "end" "for"))
(defvar plcmp4ac-re-pod-command (regexp-opt plcmp4ac-pod-commands))
(defvar plcmp4ac-re-pod-start (rx-to-string `(and bol "=" (regexp ,plcmp4ac-re-pod-command))))
(defvar plcmp4ac-re-pod-end (rx-to-string `(and bol "=cut" (* space) eol)))
(defvar plcmp4ac-re-perl-end (rx-to-string `(and bol "__END__" eol)))
(defsubst* plcmp4ac-delete-pod-in-current-buffer ()
  (goto-char (point-min))
  (when (re-search-forward plcmp4ac-re-perl-end nil t)
    (delete-region (point) (point-max)))
  (goto-char (point-min))
  (while (re-search-forward plcmp4ac-re-pod-start nil t)
    (let* ((start (point))
           (end (when (re-search-forward plcmp4ac-re-pod-end nil t) (point))))
      (when (and (number-or-marker-p start) (number-or-marker-p end) (> end start))
        (delete-region start end))))
  (goto-char (point-min)))

(defsubst* plcmp4ac-delete-comment-in-current-buffer ()
  (loop initially (goto-char (point-min))
        while (re-search-forward "#" nil t)
        for start = (progn (forward-char -1) (point))
        for end = (progn (end-of-line) (point))
        do (delete-region start end)))

(defvar plcmp4ac-re-define-variable-scalar (rx-to-string `(and (group (or "my" "our")) (+ space)
                                                               (group (or "$" "@" "%") (regexp ,plcmp-perl-ident-re)))))
(defvar plcmp4ac-re-define-variable-array (rx-to-string `(and (group (or "my" "our")) (+ space)
                                                              "(" (group (+ (not (any ")")))) ")")))
(defsubst* plcmp4ac-build-module-unknown-variables (mdl)
  (plcmp-log "plcmp4ac-build-module-unknown-variables Start for %s" (plcmp4ac-module-name mdl))
  (let* ((knownvars (append (loop for k being the hash-keys in (plcmp4ac-module-memberh mdl) collect k)
                            (loop for m being the hash-values in (plcmp4ac-module-methodh mdl)
                                  append (loop for k being the hash-keys in (plcmp4ac-method-variableh m) collect k)))))
    (goto-char (plcmp4ac-module-startpt mdl))
    (while (re-search-forward plcmp4ac-re-define-variable-scalar (plcmp4ac-module-endpt mdl) t)
      (let* ((decmethod (match-string-no-properties 1))
             (varnm (match-string-no-properties 2)))
        (when (not (member varnm knownvars))
          (plcmp4ac-build-unknown-variable-in-module varnm mdl (plcmp4ac-get-method-on-point mdl (point)) (string= decmethod "my")))))
    (goto-char (plcmp4ac-module-startpt mdl))
    (while (re-search-forward plcmp4ac-re-define-variable-array (plcmp4ac-module-endpt mdl) t)
      (let* ((decmethod (match-string-no-properties 1))
             (vars (loop for v in (split-string (match-string-no-properties 2) ",")
                         collect (replace-regexp-in-string " " "" v)))
             (known (loop for v in vars always (member v knownvars))))
        (when (not known)
          (loop with mtd = (plcmp4ac-get-method-on-point mdl (point))
                for v in vars
                if (not (member v knownvars))
                do (plcmp4ac-build-unknown-variable-in-module v mdl mtd (string= decmethod "my"))))))))
  
(defsubst* plcmp4ac-build-unknown-variable-in-module (var mdl mtd &optional lexical)
  (when (and (stringp var) (> (length var) 1))
    (let* ((idtype (substring var 0 1))
           (ret (make-plcmp4ac-variable :name var
                                          :id (substring var 1)
                                          :belong (if (plcmp4ac-method-p mtd) mtd mdl)
                                          :fullname (concat idtype
                                                            (cond ((plcmp4ac-method-p mtd)
                                                                   (plcmp4ac-method-fullname mtd))
                                                                  (t
                                                                   (plcmp4ac-module-name mdl)))
                                                            "::"
                                                            (substring var 1))
                                          :lexical lexical
                                          :type (cond ((string= idtype "$") 'plcmp4ac-scalar)
                                                      ((string= idtype "@") 'plcmp4ac-array)
                                                      ((string= idtype "%") 'plcmp4ac-hash)))))
      (when (not (gethash (plcmp4ac-variable-fullname ret) plcmp4ac-all-variable-hash))
        (puthash (plcmp4ac-variable-fullname ret) ret plcmp4ac-all-variable-hash))
      (cond ((plcmp4ac-method-p mtd)
             (puthash var ret (plcmp4ac-method-variableh mtd)))
            (t
             (puthash var ret (plcmp4ac-module-memberh mdl))))
      (plcmp-log "plcmp4ac-build-module-unknown-variables Got %s" (plcmp4ac-variable-fullname ret)))))

(defvar plcmp4ac-re-block-start-or-end (rx-to-string `(and (group (or "{" "}")))))
(defsubst* plcmp4ac-build-module-method-range-info (mdl)
  (plcmp-log "plcmp4ac-build-module-method-range-info Start for %s" (plcmp4ac-module-name mdl))
  (loop for mtd being the hash-values in (plcmp4ac-module-methodh mdl)
        for mtdnm = (plcmp4ac-method-name mtd)
        for mtdfullnm = (plcmp4ac-method-fullname mtd)
        for re = (rx-to-string `(and "sub" (+ space) (regexp ,mtdnm)))
        do (goto-char (plcmp4ac-module-startpt mdl))
        if (and (re-search-forward re nil t) (>= (point) (plcmp4ac-module-startpt mdl)) (<= (point) (plcmp4ac-module-endpt mdl)))
        do (save-excursion
             (let* ((depth 1)
                    (dstart (point))
                    (mstart (or (when (search-forward "{" (plcmp4ac-module-endpt mdl) t) (point))
                                (plcmp4ac-module-startpt mdl)))
                    (mend (or (loop while (re-search-forward plcmp4ac-re-block-start-or-end (plcmp4ac-module-endpt mdl) t)
                                    do (let* ((c (match-string-no-properties 1)))
                                         (cond ((string= c "{") (incf depth))
                                               ((string= c "}") (decf depth))))
                                    if (= depth 0) return (- (point) 1))
                              (plcmp4ac-module-startpt mdl))))
               (cond ((and (> mstart (plcmp4ac-module-startpt mdl)) (> mend (plcmp4ac-module-startpt mdl)))
                      (setf (plcmp4ac-method-start mtd) mstart)
                      (setf (plcmp4ac-method-end mtd) mend)
                      (when (string-match "PRIVATE" (buffer-substring-no-properties dstart mstart))
                        (setf (plcmp4ac-method-privately mtd) t))
                      (plcmp-log "plcmp4ac-build-module-method-range-info Got %s start[%s] end[%s]" mtdfullnm mstart mend))
                     (t
                      (plcmp-log "plcmp4ac-build-module-method-range-info Can't get range of %s" mtdfullnm)
                      (remhash mtdnm (plcmp4ac-module-methodh mdl))))))
        else
        do (progn (plcmp-log "plcmp4ac-build-module-method-range-info Not found %s" mtdfullnm)
                  (setf (plcmp4ac-method-importive mtd) t))))

(defsubst* plcmp4ac-build-substituted-variable-in-module (mdl)
  (plcmp-log "plcmp4ac-build-substituted-variable-in-module Start for %s" (plcmp4ac-module-name mdl))
  (let* ((re (rx-to-string `(and bol (group (+ (not (any "\r" "\n" "="))))
                                 (* space) "=" (* space)
                                 (group (not (any ">" ";")) (+ (not (any ";")))) ";"))))
    (goto-char (plcmp4ac-module-startpt mdl))
    (while (re-search-forward re (plcmp4ac-module-endpt mdl) t)
      (let* ((mtd (plcmp4ac-get-method-on-point mdl (point)))
             (ltext (match-string-no-properties 1))
             (rtext (match-string-no-properties 2))
             (lvar (plcmp4ac-find-variable-in-str ltext mdl mtd))
             (rvar (plcmp4ac-find-variable-in-str rtext mdl mtd)))
        (when (and (plcmp4ac-variable-p lvar) (plcmp4ac-variable-p rvar))
          (plcmp4ac-add-variable-referenced rvar lvar))))))

(defsubst* plcmp4ac-build-method-returned-in-module (mdl)
  (plcmp-log "plcmp4ac-build-method-returned-in-module Start for %s" (plcmp4ac-module-name mdl))
  (let* ((re (rx-to-string `(and "return" (+ space) (group (+ (not (any ";")))) ";"))))
    (goto-char (plcmp4ac-module-startpt mdl))
    (while (re-search-forward re (plcmp4ac-module-endpt mdl) t)
      (let* ((mtd (plcmp4ac-get-method-on-point mdl (point)))
             (ret (when (plcmp4ac-method-p mtd)
                    (plcmp4ac-method-ret mtd)))
             (value (match-string-no-properties 1))
             (rvar (when (plcmp4ac-variable-p ret)
                     (plcmp4ac-find-variable-in-str value mdl mtd))))
        (when (plcmp4ac-variable-p rvar)
          (plcmp4ac-add-variable-referenced rvar ret))))))

(defsubst* plcmp4ac-build-argument-received-in-module (mdl)
  (plcmp-log "plcmp4ac-build-argument-received-in-module Start for %s" (plcmp4ac-module-name mdl))
  (let* ((re (rx-to-string `(and bol (group (+ (not (any "\r" "\n" "="))))
                                 (* space) "=" (* space)
                                 (or "shift" "@_" (and "shift" (+ space) "@_")))))
         (indexh (make-hash-table :test 'equal)))
    (goto-char (plcmp4ac-module-startpt mdl))
    (while (re-search-forward re (plcmp4ac-module-endpt mdl) t)
      (let* ((mtd (plcmp4ac-get-method-on-point mdl (point))))
        (when (plcmp4ac-method-p mtd)
          (loop for str in (split-string (match-string-no-properties 1) ",")
                for foundvar = (or (plcmp4ac-find-variable-in-str str mdl mtd)
                                   (make-plcmp4ac-variable :name "Unknown" :id "Unknown" :fullname "Unknown"))
                for index = (or (gethash (plcmp4ac-method-name mtd) indexh)
                                0)
                for var = (cond ((< index (length (plcmp4ac-method-params mtd)))
                                 (nth index (plcmp4ac-method-params mtd)))
                                (t
                                 (while (<= (length (plcmp4ac-method-params mtd)) index)
                                   (push (make-plcmp4ac-variable :name "Unknown" :id "Unknown" :fullname "Unknown" :belong mtd)
                                         (plcmp4ac-method-params mtd)))
                                 (nth index (plcmp4ac-method-params mtd))))
                do (setf (plcmp4ac-variable-name var) (plcmp4ac-variable-name foundvar))
                do (setf (plcmp4ac-variable-fullname var) (plcmp4ac-variable-fullname foundvar))
                do (setf (plcmp4ac-variable-id var) (plcmp4ac-variable-id foundvar))
                do (puthash (plcmp4ac-method-name mtd) (incf index) indexh)))))))

(defun plcmp4ac-build-argument-sending-in-module (mdl)
  (plcmp-log "plcmp4ac-build-argument-sending-in-module Start for %s" (plcmp4ac-module-name mdl))
  (let* ((re (rx-to-string `(and bol (group (+ (not (any "=" "("))) "(" (+ (not (any "=" ";")))) ";"))))
    (goto-char (plcmp4ac-module-startpt mdl))
    (while (re-search-forward re (plcmp4ac-module-endpt mdl) t)
      (let* ((mtd (plcmp4ac-get-method-on-point mdl (point)))
             (value (match-string-no-properties 1)))
        (plcmp4ac-find-variable-in-str value mdl mtd)))))

(defsubst* plcmp4ac-find-variable-in-str (str mdl mtd)
  (plcmp-log "plcmp4ac-find-variable-in-str Start\n%s" str)
  (or (plcmp4ac-find-module-used str mdl mtd)
      (plcmp4ac-find-variable-used str mdl mtd)))

(defsubst* plcmp4ac-find-module-used (str mdl mtd)
  (let* ((using-module-re (plcmp4ac-module-usingmdlre mdl))
         (re (rx-to-string `(and (group (? (any "$" "@" "%")))
                                 (group (regexp ,using-module-re)) (or "->" "::") (group (regexp ,plcmp-perl-ident-re))
                                 (group (* anything))))))
    (when (string-match re str)
      (plcmp-log "plcmp4ac-find-module-used Matched")
      (let* ((vartype (match-string-no-properties 1 str))
             (foundmdlnm (match-string-no-properties 2 str))
             (somenm (match-string-no-properties 3 str))
             (subtext (match-string-no-properties 4 str))
             (foundmdl (plcmp4ac-get-module-info foundmdlnm))
             (foundmtd (when (and (plcmp4ac-module-p foundmdl)
                                  (or (not (stringp vartype)) (string= vartype "")))
                         (gethash somenm (plcmp4ac-module-methodh foundmdl))))
             (varnm (concat (if (stringp vartype) vartype "") somenm))
             (varfullnm (concat (if (stringp vartype) vartype "") foundmdlnm "::" somenm))
             (var (make-plcmp4ac-variable :name varnm :fullname varfullnm :id somenm))
             (maybe (when (and (plcmp4ac-method-p foundmtd)
                               (or (string= somenm "new") (string= somenm "New") (string= somenm "NEW")))
                      foundmdl)))
        (when (not (plcmp4ac-method-p foundmtd))
          (setq var (plcmp4ac-build-variable-member-info var subtext)))
        ;; (when (and (> (length subtext) 0) (string= (substring subtext 0 1) "("))
        ;;   (let* ((end (plcmp4ac-index-of-closed-bracket-curly subtext 1)))
        ;;     (plcmp4ac-build-method-argument-info mtd var somenm 0 (substring subtext 1 end))))
        (plcmp4ac-regist-found-variable var foundmdl foundmtd t maybe)))))

(defsubst* plcmp4ac-find-variable-used (str mdl mtd)
  (let* ((var-re (plcmp4ac-module-varre mdl))
         (re (rx-to-string `(and (group (* (any "$" "@" "%" "{")))
                                 (group (any "$" "@" "%") (regexp ,var-re))
                                 (group (* anything))))))
    (when (string-match re str)
      (plcmp-log "plcmp4ac-find-variable-used Matched")
      (let* ((pretext (match-string-no-properties 1 str))
             (varnm (match-string-no-properties 2 str))
             (subtext (match-string-no-properties 3 str))
             (subtext (loop with ret = subtext
                            with do_rep
                            for i from 0 below (length pretext)
                            for c = (substring pretext i (+ i 1))
                            if (or (string= c "$") (string= c "@") (string= c "%"))
                            do (setq do_rep t)
                            else if do_rep
                            do (progn (cond ((string= c "{")
                                             (let* ((index (plcmp4ac-index-of-closed-bracket-wavy ret 0)))
                                               (setq ret (concat (if (> index 0) (substring ret 0 index) "")
                                                                 "->"
                                                                 (if (< index (- (length ret) 1)) (substring ret (+ index 1)) "")))))
                                            (t
                                             (setq ret (concat "->" ret))))
                                      (setq do_rep nil))
                            finally return ret))
             (var (make-plcmp4ac-variable :name varnm :fullname varnm :id (substring varnm 1)))
             (var (plcmp4ac-build-variable-member-info var subtext)))
        (plcmp4ac-regist-found-variable var mdl mtd nil nil)))))

(defun* plcmp4ac-build-variable-member-info (var str &optional (depth 1))
  (when (and (plcmp4ac-variable-p var) (stringp str))
    (if (> depth 5)
        (progn (plcmp-log "plcmp4ac-build-variable-member-info Over depth limit")
               var)
      (plcmp-log "plcmp4ac-build-variable-member-info Start for %s\n%s" (plcmp4ac-variable-fullname var) str)
      (incf depth)
      (let* ((re-hash (rx-to-string `(and bol "{")))
             (re-array (rx-to-string `(and bol "[")))
             (re-refhash (rx-to-string `(and bol "->{")))
             (re-refarray (rx-to-string `(and bol "->[")))
             (re-sub (rx-to-string `(and bol "->" (group (regexp ,plcmp-perl-ident-re)))))
             (subnm "")
             (start 0)
             (end (cond ((string-match re-hash str)
                         (setf (plcmp4ac-variable-type var) 'plcmp4ac-hash)
                         (setf (plcmp4ac-variable-name var)
                               (replace-regexp-in-string "^\$" "%" (plcmp4ac-variable-name var)))
                         (setf (plcmp4ac-variable-fullname var)
                               (replace-regexp-in-string "^\$" "%" (plcmp4ac-variable-fullname var)))
                         (setq start 1)
                         (plcmp4ac-index-of-closed-bracket-wavy str 1))
                        ((string-match re-array str)
                         (setf (plcmp4ac-variable-type var) 'plcmp4ac-array)
                         (setf (plcmp4ac-variable-name var)
                               (replace-regexp-in-string "^\$" "@" (plcmp4ac-variable-name var)))
                         (setf (plcmp4ac-variable-fullname var)
                               (replace-regexp-in-string "^\$" "@" (plcmp4ac-variable-fullname var)))
                         (setq start 1)
                         (plcmp4ac-index-of-closed-bracket-angled str 1))
                        ((string-match re-refhash str)
                         (setf (plcmp4ac-variable-type var) 'plcmp4ac-refhash)
                         (setq start 3)
                         (plcmp4ac-index-of-closed-bracket-wavy str 3))
                        ((string-match re-refarray str)
                         (setf (plcmp4ac-variable-type var) 'plcmp4ac-refarray)
                         (setq start 3)
                         (plcmp4ac-index-of-closed-bracket-angled str 3))
                        ((string-match re-sub str)
                         (setq subnm (match-string-no-properties 1 str))
                         (setq str (replace-regexp-in-string re-sub "" str))
                         (length str))
                        (t
                         (length str)))))
        (cond ((< end (length str))
               ;; Exist member
               (let* ((membernm (plcmp4ac-identify-member (substring str start end)))
                      (fullmembernm (concat (case (plcmp4ac-variable-type var)
                                              (plcmp4ac-hash "{")
                                              (plcmp4ac-array "[")
                                              (plcmp4ac-refhash "->{")
                                              (plcmp4ac-refarray "->[")
                                              (t ""))
                                            membernm
                                            (case (plcmp4ac-variable-type var)
                                              (plcmp4ac-hash "}")
                                              (plcmp4ac-array "]")
                                              (plcmp4ac-refhash "}")
                                              (plcmp4ac-refarray "]")
                                              (t ""))))
                      (varnm (concat "$"
                                     (substring (plcmp4ac-variable-name var) 1)
                                     fullmembernm))
                      (fullvarnm (concat "$"
                                         (substring (plcmp4ac-variable-fullname var) 1)
                                         fullmembernm))
                      (member (or (gethash fullvarnm plcmp4ac-all-variable-hash)
                                  (puthash fullvarnm
                                           (make-plcmp4ac-variable :name varnm
                                                                   :id (substring varnm 1)
                                                                   :belong var
                                                                   :fullname fullvarnm
                                                                   :type 'plcmp4ac-unknown)
                                           plcmp4ac-all-variable-hash))))
                 (puthash membernm member (plcmp4ac-variable-memberh var))
                 (cond ((< end (- (length str) 1))
                        ;; Exist nested variable
                        (plcmp4ac-build-variable-member-info member (substring str (+ end 1)) depth))
                       (t
                        member))))
              ((not (string= subnm ""))
               ;; Call sub
               (let* ((subret (make-plcmp4ac-variable :name subnm :id subnm))
                      (hook (list 'plcmp4ac-bind-variable-for-method-returned '(subnm subret))))
                 (plcmp4ac-add-variable-after-set-maybe-hook var hook)
                 (cond ((and (> (length str) 0) (string= (substring str 0 1) "("))
                        (let* ((end (plcmp4ac-index-of-closed-bracket-curly str 1)))
                          (plcmp4ac-build-variable-member-info subret (substring str end) depth)))
                       ((> (length str) 0)
                        (plcmp4ac-build-variable-member-info subret str depth))
                       (t
                        subret))))
              (t
               ;; Unmatch or incompletion text
               var))))))

(defun plcmp4ac-build-method-argument-info (mtd mdl_or_var subnm index str)
  (when (and (stringp str) (> (length str) 0))
    (let* ((end (loop with i = 0
                      for c = (cond ((< i (length str)) (substring str i (+ i 1)))
                                    (t                  ""))
                      while (< i (length str))
                      if (string= c ",") return i
                      if (string= c "{") do (setq i (plcmp4ac-index-of-closed-bracket-wavy str (+ i 1)))
                      if (string= c "(") do (setq i (plcmp4ac-index-of-closed-bracket-curly str (+ i 1)))
                      if (string= c "[") do (setq i (plcmp4ac-index-of-closed-bracket-angled str (+ i 1)))
                      do (incf i)
                      finally return i))
           (subtext (cond ((= end 0)            "")
                          ((< end (length str)) (substring str 0 end))
                          (t                    str)))
           (remain (cond ((= end 0)            str)
                         ((< end (length str)) (substring str (+ end 1)))
                         (t                    "")))
           (var (when (not (string= subtext ""))
                  (plcmp4ac-find-variable-in-str subtext mdl mtd))))
      (when (plcmp4ac-variable-p var)
        (cond ((plcmp4ac-module-p mdl_or_var)
               (let* ((m (gethash subnm (plcmp4ac-module-methodh mdl_or_var)))
                      (v (when (plcmp4ac-method-p m)
                           (while (<= (length (plcmp4ac-method-params m)) index)
                             (push (make-plcmp4ac-variable :name "Unknown" :id "Unknown" :fullname "Unknown" :belong m)
                                   (plcmp4ac-method-params m)))
                           (nth index (plcmp4ac-method-params m)))))
                 (when (plcmp4ac-variable-p v)
                   (plcmp4ac-add-variable-referenced var v))))
              ((plcmp4ac-variable-p mdl_or_var)
               (plcmp4ac-add-variable-after-set-maybe-hook mdl_or_var
                                                           (list 'plcmp4ac-add-reference-for-method-argument
                                                                 '(subnm var index))))))
      (plcmp4ac-build-method-argument-info mtd mdl_or_var subnm (incf index) remain))))

(defsubst* plcmp4ac-regist-found-variable (var mdl mtd is_mtd maybe)
  (when (plcmp4ac-module-p mdl)
    (let* ((searchmembers)
           (rootvar (loop with ret = var
                          while (plcmp4ac-variable-p (plcmp4ac-variable-belong ret))
                          do (push (plcmp4ac-variable-name ret) searchmembers)
                          do (setq ret (plcmp4ac-variable-belong ret))
                          finally return ret))
           (orgvar (or (when (plcmp4ac-method-p mtd)
                         (cond (is_mtd (plcmp4ac-method-ret mtd))
                               (t         (gethash (plcmp4ac-variable-name rootvar) (plcmp4ac-method-variableh mtd)))))
                       (gethash (plcmp4ac-variable-name rootvar) (plcmp4ac-module-memberh mdl)))))
      (when (plcmp4ac-variable-p orgvar)
        (plcmp4ac-merge-variable-member rootvar orgvar)
        (when (plcmp4ac-module-p maybe)
          (plcmp-log "plcmp4ac-regist-found-variable %s maybe %s"
                     (plcmp4ac-variable-fullname orgvar)
                     (plcmp4ac-module-name maybe))
          (plcmp4ac-set-variable-maybe orgvar maybe))
        (loop with ret = orgvar
              for e in (reverse searchmembers)
              for v = (when (plcmp4ac-variable-p ret)
                        (gethash e (plcmp4ac-variable-memberh ret)))
              if (plcmp4ac-variable-p v) do (setq ret v)
              finally return (progn (plcmp-log "plcmp4ac-regist-found-variable Ret %s (Update %s)"
                                               (plcmp4ac-variable-fullname ret)
                                               (plcmp4ac-variable-fullname orgvar))
                                    ret))))))

(defun plcmp4ac-set-variable-maybe (var maybe)
  (when (and (plcmp4ac-variable-p var) (plcmp4ac-module-p maybe))
    (plcmp-log "plcmp4ac-set-variable-maybe %s maybe %s" (plcmp4ac-variable-fullname var) (plcmp4ac-module-name maybe))
    (setf (plcmp4ac-variable-maybe var) maybe)
    (loop for hook in (plcmp4ac-variable-aftersetmaybehooks var)
          for func = (car hook)
          for args = (cdr hook)
          do (funcall func var args))
    (loop for v in (plcmp4ac-variable-referenced var) do (plcmp4ac-set-variable-maybe v maybe))))

(defun plcmp4ac-add-variable-referenced (var referencing)
  (when (and (plcmp4ac-variable-p var) (plcmp4ac-variable-p referencing))
    (plcmp-log "plcmp4ac-add-variable-referenced %s refs %s"
               (plcmp4ac-variable-fullname referencing)
               (plcmp4ac-variable-fullname var))
    (push referencing (plcmp4ac-variable-referenced var))
    (setf (plcmp4ac-variable-referencing referencing) var)
    ;; If already exist maybe, set it for referencing variable
    (when (plcmp4ac-module-p (plcmp4ac-variable-maybe var))
      (plcmp4ac-set-variable-maybe referencing (plcmp4ac-variable-maybe var)))))

(defun plcmp4ac-add-variable-after-set-maybe-hook (var hook)
  (when (plcmp4ac-variable-p var)
    (if (not (plcmp4ac-module-p (plcmp4ac-variable-maybe var)))
        (push hook (plcmp4ac-variable-aftersetmaybehooks var))
      (let* ((func (car hook))
             (args (cdr hook)))
        (funcall func var args)))))
    
(defun plcmp4ac-add-reference-for-method-returned (var args)
  (let* ((mtdnm (pop args))
         (referencing (pop args))
         (maybe (when (plcmp4ac-variable-p var)
                  (plcmp4ac-variable-maybe var)))
         (referenced (when (and (plcmp4ac-module-p maybe) (stringp mtdnm))
                       (or (gethash (concat (plcmp4ac-module-name maybe) "::" mtdnm) plcmp4ac-all-variable-hash)
                           (puthash (concat (plcmp4ac-module-name maybe) "::" mtdnm)
                                    (make-plcmp4ac-variable :name mtdnm
                                                            :id mtdnm
                                                            :fullname (concat (plcmp4ac-module-name maybe) "::" mtdnm)
                                                            :lexical t)
                                    plcmp4ac-all-variable-hash)))))
    (plcmp4ac-add-variable-referenced referenced referencing)))

(defun plcmp4ac-add-reference-for-method-argument (var args)
  (let* ((mtdnm (pop args))
         (referenced (pop args))
         (index (pop args))
         (maybe (when (plcmp4ac-variable-p var)
                  (plcmp4ac-variable-maybe var)))
         (mtd (when (and (plcmp4ac-module-p maybe) (stringp mtdnm))
                   (gethash mtdnm (plcmp4ac-module-methodh maybe))))
         (referencing (when (and (plcmp4ac-method-p mtd) (integerp index))
                        (while (<= (length (plcmp4ac-method-params mtd)) index)
                          (push (make-plcmp4ac-variable :name "Unknown" :id "Unknown" :fullname "Unknown" :belong mtd)
                                (plcmp4ac-method-params mtd)))
                        (nth index (plcmp4ac-method-params mtd)))))
    (plcmp4ac-add-variable-referenced referenced referencing)))

(defun plcmp4ac-bind-variable-for-method-returned (var args)
  (let* ((mtdnm (pop args))
         (bindvar (pop args))
         (maybe (when (plcmp4ac-variable-p var)
                  (plcmp4ac-variable-maybe var)))
         (mtd (when (and (plcmp4ac-module-p maybe) (stringp mtdnm))
                   (gethash mtdnm (plcmp4ac-module-methodh maybe))))
         (ret (when (plcmp4ac-method-p mtd)
                (plcmp4ac-method-ret mtd))))
    (when (plcmp4ac-method-p mtd)
      (if (plcmp4ac-variable-p ret)
          (plcmp4ac-merge-variable-member bindvar ret)
        (setf (plcmp4ac-variable-fullname bindvar) (concat (plcmp4ac-module-name maybe) "::" mtdnm))
        (setf (plcmp4ac-variable-belong bindvar) mtd)
        (setf (plcmp4ac-variable-lexical bindvar) t)
        (setf (plcmp4ac-method-ret mtd) bindvar)))))

(defun plcmp4ac-add-after-set-maybe-hook-for-method-returned (var args)
  (let* ((mtdnm (pop args))
         (hook args)
         (maybe (when (plcmp4ac-variable-p var)
                  (plcmp4ac-variable-maybe var)))
         (hooked (when (and (plcmp4ac-module-p maybe) (stringp mtdnm))
                   (or (gethash (concat (plcmp4ac-module-name maybe) "::" mtdnm) plcmp4ac-all-variable-hash)
                       (puthash (concat (plcmp4ac-module-name maybe) "::" mtdnm)
                                (make-plcmp4ac-variable :name mtdnm
                                                        :id mtdnm
                                                        :fullname (concat (plcmp4ac-module-name maybe) "::" mtdnm)
                                                        :lexical t)
                                plcmp4ac-all-variable-hash)))))
    (when (plcmp4ac-variable-p hooked)
      (plcmp4ac-add-variable-after-set-maybe-hook hooked hook))))

(defun plcmp4ac-merge-variable-member (fromvar mergedver)
  (when (and (plcmp4ac-variable-p mergedver) (plcmp4ac-variable-p fromvar))
    (setf (plcmp4ac-variable-type mergedver) (plcmp4ac-variable-type fromvar))
    (loop for hook in (plcmp4ac-variable-aftersetmaybehooks fromvar)
          do (push hook (plcmp4ac-variable-aftersetmaybehooks mergedver)))
    (loop for k being the hash-keys in (plcmp4ac-variable-memberh fromvar) using (hash-values frommember)
          for mergedmember = (gethash k (plcmp4ac-variable-memberh mergedver))
          if (plcmp4ac-variable-p mergedmember)
          do (plcmp4ac-merge-variable-member frommember mergedmember)
          else
          do (puthash k frommember (plcmp4ac-variable-memberh mergedver)))))

(defsubst* plcmp4ac-identify-member (str)
  (let* ((str (replace-regexp-in-string "^\\s-+" "" str))
         (str (replace-regexp-in-string "\\s-+$" "" str))
         (str (replace-regexp-in-string "^\\(\"\\|'\\)" "" str))
         (str (replace-regexp-in-string "\\(\"\\|'\\)$" "" str)))
    (when (not (string-match "^[a-zA-Z_0-9]+$" str))
      (setq str "*"))
    str))

(defun plcmp4ac-build-builtin-variable-info ()
  (when (not (hash-table-p plcmp4ac-builtin-variable-hash))
    (let* ((html (shell-command-to-string "perldoc -oHtml perlvar")))
      (setq plcmp4ac-builtin-variable-hash (make-hash-table :test 'equal))
      (with-temp-buffer
        (insert (plcmp4ac-render-html html))
        (loop with doc = ""
              with asdoc
              with varnms
              with re = (rx-to-string `(and bol (group (+ (not space)))))
              with regist = (lambda (varnms doc)
                              (dolist (varnm varnms)
                                (when (and (stringp varnm) (> (length varnm) 1))
                                  (puthash varnm
                                           (make-plcmp4ac-variable :name varnm
                                                                   :fullname varnm
                                                                   :id (substring varnm 1)
                                                                   :type (cond ((string= (substring varnm 0 1) "%")
                                                                                'plcmp4ac-hash)
                                                                               ((string= (substring varnm 0 1) "@")
                                                                                'plcmp4ac-array)
                                                                               (t
                                                                                'plcmp4ac-scalar))
                                                                   :helptext doc)
                                           plcmp4ac-builtin-variable-hash)
                                  (plcmp-log "plcmp4ac-build-builtin-variable-info Got document of %s" varnm))))
              initially (goto-char (point-min))
              for line = (thing-at-point 'line)
              for line = (progn (set-text-properties 0 (string-width line) nil line)
                                line)
              for w = (cond ((string-match re line) (car (split-string line)))
                            (t ""))
              while (and (not (eobp))
                         (not (string= line "Error Indicators")))
              do (cond ((member w plcmp-builtin-variables)
                        (when asdoc
                          (funcall regist varnms doc)
                          (setq varnms nil)
                          (setq doc "")
                          (setq asdoc nil))
                        (push w varnms)
                        (setq doc (concat doc line)))
                       ((not (string= w ""))
                        nil)
                       (t
                        (when (>= (length varnms) 1)
                          (setq asdoc t))
                        (setq doc (concat doc line))))
              do (forward-line 1)
              finally (funcall regist varnms doc))))))

(defun plcmp4ac-build-builtin-function-info ()
  (when (not (hash-table-p plcmp4ac-builtin-function-hash))
    (let* ((html (shell-command-to-string "perldoc -oHtml perlfunc"))
           (re (rx-to-string `(and bol "<dt><a name=\"" (group (+ (any "a-z/")))
                                   (* (any "a-z_,")) "\""))))
      (with-temp-buffer
        (insert html)
        (loop initially (goto-char (point-min))
              for w = (match-string-no-properties 1)
              while (re-search-forward re nil t)
              if (and (not (null w))
                      (not (string= w "Functions"))
                      (not (string= w "Regular"))
                      (not (string= w "Numeric"))
                      (not (string= w "Input"))
                      (not (string= w "Keywords"))
                      (not (string= w "Miscellaneous"))
                      (not (string= w "System"))
                      (not (string= w "Fetching")))
              do (add-to-list 'plcmp-builtin-functions w))
        (setq plcmp-builtin-functions (reverse plcmp-builtin-functions))
        (plcmp-log "plcmp4ac-build-builtin-function-info List is %s" plcmp-builtin-functions)
        (plcmp-log "plcmp4ac-build-builtin-function-info LENGTH is %s" (length plcmp-builtin-functions))
        (setq plcmp4ac-builtin-function-hash (make-hash-table :test 'equal))
        (erase-buffer)
        (insert (plcmp4ac-render-html html))
        (loop with doc = ""
              with funcnm = ""
              with re = (rx-to-string `(and bol (group (+ (not space)))))
              with regist = (lambda (funcnm doc)
                              (puthash funcnm
                                       (make-plcmp4ac-method :name funcnm
                                                             :fullname funcnm
                                                             :params (plcmp4ac-get-params-from-perldoc funcnm doc)
                                                             :ret (make-plcmp4ac-variable :name "Unknown"
                                                                                          :id "Unknown"
                                                                                          :fullname "Unknown"
                                                                                          :lexical t)
                                                             :helptext doc)
                                       plcmp4ac-builtin-function-hash)
                              (plcmp-log "plcmp4ac-build-builtin-function-info Got document of %s" funcnm))
              initially (goto-char (point-min))
              for line = (thing-at-point 'line)
              for line = (progn (set-text-properties 0 (string-width line) nil line)
                                line)
              for w = (cond ((string-match re line) (car (split-string line)))
                            (t ""))
              until (eobp)
              do (when (and (member w plcmp-builtin-functions)
                            (not (string= w funcnm)))
                   (when (not (string= funcnm ""))
                     (funcall regist funcnm doc))
                   (setq funcnm w)
                   (setq doc ""))
              do (setq doc (concat doc line))
              do (forward-line 1)
              finally (funcall regist funcnm doc))))))

(defsubst* plcmp4ac-get-params-from-perldoc (funcnm doc)
  (loop for line in (split-string doc "\r?\n")
        for text = (replace-regexp-in-string (concat "^\\s-*" funcnm) "" line)
        for trimmed = (replace-regexp-in-string "^\\s-+" "" text)
        for trimmed = (replace-regexp-in-string "\\s-+$" "" trimmed)
        if (= (length line) (length text)) return ret
        collect (loop for e in (split-string trimmed ",")
                      append (loop for e in (split-string e)
                                   for type = (cond ((string= e "BLOCK") 'plcmp4ac-block)
                                                    ((string= e "LIST") 'plcmp4ac-array)
                                                    ((string= e "EXPR") 'plcmp4ac-expr)
                                                    (t 'plcmp4ac-scalar))
                                   for varnm = (concat (case type
                                                         (plcmp4ac-block "{")
                                                         (plcmp4ac-scalar "$")
                                                         (plcmp4ac-array "@")
                                                         (plcmp4ac-expr "/"))
                                                       (downcase e)
                                                       (case type
                                                         (plcmp4ac-block "}")
                                                         (plcmp4ac-scalar "")
                                                         (plcmp4ac-array "")
                                                         (plcmp4ac-expr "/")))
                                   collect (make-plcmp4ac-variable :name varnm
                                                                   :fullname (concat funcnm "::" varnm)
                                                                   :id (downcase e)
                                                                   :type type)))
        into ret))

(defun plcmp4ac-echo-method-usage ()
  "")

(defun plcmp4ac-make-document (selected)
  (when (stringp selected)
    (set-text-properties 0 (string-width selected) nil selected)
    (ignore-errors
      (with-temp-buffer
        (let* ((standard-output (current-buffer))
               (mdl (gethash selected plcmp4ac-available-module-hash))
               (doc (or (when (plcmp4ac-module-p mdl) (plcmp4ac-module-helptext mdl))
                        (plcmp4ac-get-document-of-function selected)
                        (plcmp4ac-get-document-of-variable selected)
                        plcmp4ac-document-value-of-not-found)))
          (princ doc)
          (buffer-string))))))

(defun plcmp4ac-make-document-of-module (selected)
  (when (stringp selected)
    (set-text-properties 0 (string-width selected) nil selected)
    (ignore-errors
      (with-temp-buffer
        (let* ((standard-output (current-buffer))
               (mdl (gethash selected plcmp4ac-available-module-hash)))
          (cond ((plcmp4ac-module-p mdl)
                 (princ (plcmp4ac-module-helptext mdl)))
                (t
                 (princ plcmp4ac-document-value-of-not-found)))
          (buffer-string))))))

(defun plcmp4ac-make-document-of-function (selected)
  (when (stringp selected)
    (set-text-properties 0 (string-width selected) nil selected)
    (ignore-errors
      (with-temp-buffer
        (let* ((standard-output (current-buffer))
               (doc (plcmp4ac-get-document-of-function selected)))
          (cond ((stringp doc) (princ doc))
                (t             (princ plcmp4ac-document-value-of-not-found)))
          (buffer-string))))))

(defun plcmp4ac-make-document-of-variable (selected)
  (when (stringp selected)
    (set-text-properties 0 (string-width selected) nil selected)
    (ignore-errors
      (with-temp-buffer
        (let* ((standard-output (current-buffer))
               (doc (plcmp4ac-get-document-of-variable selected)))
          (cond ((stringp doc) (princ doc))
                (t             (princ plcmp4ac-document-value-of-not-found)))
          (buffer-string))))))

(defun plcmp4ac-make-document-of-array-on-scalar (selected)
  (when (stringp selected)
    (set-text-properties 0 (string-width selected) nil selected)
    (plcmp4ac-make-document-of-variable (replace-regexp-in-string "^\$" "@" selected))))
(defun plcmp4ac-make-document-of-hash-on-scalar (selected)
  (when (stringp selected)
    (set-text-properties 0 (string-width selected) nil selected)
    (plcmp4ac-make-document-of-variable (replace-regexp-in-string "^\$" "%" selected))))
(defun plcmp4ac-make-document-of-array-on-arraysize (selected)
  (when (stringp selected)
    (set-text-properties 0 (string-width selected) nil selected)
    (plcmp4ac-make-document-of-variable (replace-regexp-in-string "^\$#" "@" selected))))

(defun plcmp4ac-get-document-of-function (funcnm)
  (let* ((re (rx-to-string `(and bol (group (+ not-newline)) "::" (group (+ (not (any ":")))) eol)))
         (mdlnm (cond ((eq plcmp4ac-current-context 'package)
                          plcmp4ac-current-package-name)
                         ((string-match re funcnm)
                          (prog1 (match-string-no-properties 1 funcnm)
                            (setq funcnm (match-string-no-properties 2 funcnm))))
                         ((stringp plcmp4ac-current-dependent)
                          (cond ((string= plcmp4ac-current-dependent "$self")
                                 plcmp4ac-current-package-name)
                                ((string= plcmp4ac-current-dependent "$class")
                                 plcmp4ac-current-package-name)
                                (t
                                 plcmp4ac-current-dependent)))))
         (methods (cond ((not (stringp mdlnm))
                         (plcmp4ac-get-static-methods-in-current t))
                        ((string= mdlnm "SUPER")
                         (plcmp4ac-get-inherit-methods-in-module plcmp4ac-current-package-name t))
                        (t
                         (plcmp4ac-get-public-methods-in-module mdlnm t)))))
    (loop for m in methods
          if (and (plcmp4ac-method-p m)
                  (string= funcnm (plcmp4ac-method-name m)))
          return (plcmp4ac-method-helptext m))))

(defun plcmp4ac-get-document-of-variable (varnm)
  (let* ((re (rx-to-string `(and bol (group (any "$" "@" "%")) (group (+ not-newline)) "::" (group (+ (not (any ":")))) eol)))
         (mdlnm (when (string-match re varnm)
                     (prog1 (match-string-no-properties 2 varnm)
                       (setq varnm (concat (match-string-no-properties 1 varnm) (match-string-no-properties 3 varnm))))))
         (type-char (if (> (length varnm) 0) (substring varnm 0 1) ""))
         (var-type (cond ((string= type-char "$") 'plcmp4ac-scalar)
                         ((string= type-char "@") 'plcmp4ac-array)
                         ((string= type-char "%") 'plcmp4ac-hash)))
         (variables (cond ((not (stringp mdlnm))
                           (plcmp4ac-get-available-variables var-type t))
                          ((string= mdlnm "SUPER")
                           (loop with currm = (plcmp4ac-get-module-info plcmp4ac-current-package-name)
                                 for m in (plcmp4ac-module-parents currm)
                                 append (plcmp4ac-get-public-variables-in-module m var-type t)))
                          (t
                           (plcmp4ac-get-public-variables-in-module mdlnm var-type t)))))
    (loop for v in variables
          if (and (plcmp4ac-variable-p v)
                  (string= varnm (plcmp4ac-variable-name v)))
          return (plcmp4ac-variable-helptext v))))

(defvar ac-source-plcmp4ac-on-scalar
  '((init . plcmp4ac-initialize-variables)
    (candidates . plcmp4ac-get-available-scalars)
    (prefix . "\$[a-zA-Z_0-9:]*")
    (symbol . "s")
    (document . plcmp4ac-make-document-of-variable)
    (requires . 0)
    (cache)))

(defvar ac-source-plcmp4ac-on-array
  '((init . plcmp4ac-initialize-variables)
    (candidates . plcmp4ac-get-available-arrays)
    (prefix . "@[a-zA-Z_0-9:]*")
    (symbol . "a")
    (document . plcmp4ac-make-document-of-variable)
    (requires . 0)
    (cache)))

(defvar ac-source-plcmp4ac-on-hash
  '((init . plcmp4ac-initialize-variables)
    (candidates . plcmp4ac-get-available-hashes)
    (prefix . "%[a-zA-Z_0-9:]*")
    (symbol . "h")
    (document . plcmp4ac-make-document-of-variable)
    (requires . 0)
    (cache)))

(defvar ac-source-plcmp4ac-on-scalar-but-array
  '((init . plcmp4ac-initialize-variables)
    (candidates . plcmp4ac-get-available-arrays-on-scalar)
    (prefix . "\$[a-zA-Z_0-9:]*")
    (symbol . "a")
    (document . plcmp4ac-make-document-of-array-on-scalar)
    (requires . 0)
    (action . (lambda ()
                (when (or (eolp)
                          (string= (format "%c" (char-after)) " "))
                  (insert "[]")
                  (forward-char -1))))
    (cache)))

(defvar ac-source-plcmp4ac-on-scalar-but-hash
  '((init . plcmp4ac-initialize-variables)
    (candidates . plcmp4ac-get-available-hashes-on-scalar)
    (prefix . "\$[a-zA-Z_0-9:]*")
    (symbol . "h")
    (document . plcmp4ac-make-document-of-hash-on-scalar)
    (requires . 0)
    (action . (lambda ()
                (when (or (eolp)
                          (string= (format "%c" (char-after)) " "))
                  (insert "{}")
                  (forward-char -1))))
    (cache)))

(defvar ac-source-plcmp4ac-on-array-size
  '((init . plcmp4ac-initialize-variables)
    (candidates . plcmp4ac-get-available-arrays-on-arraysize)
    (prefix . "$#[a-zA-Z_0-9:]*")
    (symbol . "a")
    (document . plcmp4ac-make-document-of-array-on-arraysize)
    (requires . 0)
    (cache)))

(defvar ac-source-plcmp4ac-on-arrow
  '((init . plcmp4ac-initialize-variables)
    (candidates . plcmp4ac-make-candidates)
    (prefix . "->\\([a-zA-Z_0-9:]*\\)")
    (symbol . "m")
    (document . plcmp4ac-make-document-of-function)
    (requires . 0)
    (cache)))

(defvar ac-source-plcmp4ac-on-amp
  '((init . plcmp4ac-initialize-variables)
    (candidates . plcmp4ac-get-static-methods-in-current)
    (prefix . "&\\([a-zA-Z_0-9:]*\\)")
    (symbol . "f")
    (document . plcmp4ac-make-document-of-function)
    (requires . 0)
    (cache)))

(defvar ac-source-plcmp4ac-on-sub
  '((init . plcmp4ac-initialize-variables)
    (candidates . (plcmp4ac-get-all-methods-in-module plcmp4ac-current-package-name))
    (prefix . "\\<sub\\s-+\\([a-zA-Z_0-9]*\\)")
    (symbol . "d")
    (document . plcmp4ac-make-document-of-function)
    (requires . 0)
    (cache)))

(defvar ac-source-plcmp4ac-on-use
  '((init . plcmp4ac-initialize-variables)
    (candidates . plcmp-installed-modules)
    (prefix . "\\<\\(?:use\\|require\\)\\s-+\\([a-zA-Z_0-9:]*\\)")
    (symbol . "p")
    (document . plcmp4ac-make-document-of-module)
    (requires . 0)
    (action . (lambda () (plcmp4ac-build-module-info (ac-selected-candidate))))
    (cache)))

(defvar ac-source-plcmp4ac-other
  '((init . plcmp4ac-initialize-variables)
    (candidates . plcmp4ac-make-candidates)
    (prefix . "\\s-+\\([a-zA-Z_0-9:\-/\\.]+\\)")
    (symbol . "o")
    (document . plcmp4ac-make-document)
    (cache)))

(defvar ac-source-plcmp4ac-other-on-bol
  '((init . plcmp4ac-initialize-variables)
    (candidates . plcmp4ac-make-candidates)
    (prefix . "^\\([a-zA-Z_0-9:\-/\\.]+\\)")
    (symbol . "o")
    (document . plcmp4ac-make-document)
    (cache)))

(defvar ac-source-plcmp4ac-other-on-etc
  '((init . plcmp4ac-initialize-variables)
    (candidates . plcmp4ac-make-candidates)
    (prefix . "[\"'`({\[<]\\([a-zA-Z_0-9:\-/\\.]+\\)")
    (symbol . "o")
    (document . plcmp4ac-make-document)
    (cache)))

(defun plcmp4ac-regist-current-modules-to-update ()
  (when (string= (symbol-name major-mode) "cperl-mode")
    (dolist (mdlnm (plcmp4ac-get-package-names-in-buffer (current-buffer)))
      (cond ((and (string= mdlnm "main")
                  (stringp (buffer-file-name)))
             (pushnew (buffer-file-name) plcmp4ac-should-update-file-names :test 'equal))
            (t
             (pushnew mdlnm plcmp4ac-should-update-modules :test 'equal))))))
(add-hook 'after-save-hook 'plcmp4ac-regist-current-modules-to-update t)

(defun plcmp4ac-setup ()
  (interactive)
  (add-to-list 'ac-sources 'ac-source-plcmp4ac-on-scalar)
  (add-to-list 'ac-sources 'ac-source-plcmp4ac-on-array)
  (add-to-list 'ac-sources 'ac-source-plcmp4ac-on-hash)
  (add-to-list 'ac-sources 'ac-source-plcmp4ac-on-scalar-but-array)
  (add-to-list 'ac-sources 'ac-source-plcmp4ac-on-scalar-but-hash)
  (add-to-list 'ac-sources 'ac-source-plcmp4ac-on-array-size)
  (add-to-list 'ac-sources 'ac-source-plcmp4ac-on-arrow)
  (add-to-list 'ac-sources 'ac-source-plcmp4ac-on-amp)
  (add-to-list 'ac-sources 'ac-source-plcmp4ac-on-sub)
  (add-to-list 'ac-sources 'ac-source-plcmp4ac-on-use)
  (add-to-list 'ac-sources 'ac-source-plcmp4ac-other)
  (add-to-list 'ac-sources 'ac-source-plcmp4ac-other-on-bol)
  (add-to-list 'ac-sources 'ac-source-plcmp4ac-other-on-etc)
  (local-set-key (kbd ">") 'self-insert-with-ac-trigger-command)
  (local-set-key (kbd "$") 'self-insert-with-ac-trigger-command)
  (local-set-key (kbd "@") 'self-insert-with-ac-trigger-command)
  (local-set-key (kbd "%") 'self-insert-with-ac-trigger-command)
  (local-set-key (kbd "&") 'self-insert-with-ac-trigger-command)
  (perl-completion-mode t)
  (set (make-local-variable 'eldoc-documentation-function) 'plcmp4ac-echo-method-usage)
  (turn-on-eldoc-mode)
  (setq plcmp4ac-buffer-file-name (buffer-file-name))
  (plcmp4ac-build-builtin-function-info)
  (plcmp4ac-build-builtin-variable-info)
  ;; (dolist (pkg (plcmp4ac-get-package-names-in-buffer (current-buffer)))
  ;;   (plcmp4ac-build-module-info pkg nil t))
  (plcmp4ac-initialize-variables))

(defun plcmp4ac-call-process ()
  (interactive)
  (message "%s" (executable-find "perl-completion4ac/mkmoduleinfo.pl")))

(provide 'perl-completion4ac)

